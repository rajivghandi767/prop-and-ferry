pipeline {
    agent any

    // 1. Scheduled Trigger (02:45 AM ET Daily)
    triggers {
        cron('''TZ=America/New_York
45 2 * * *''')
    }

    // 2. Rollback Parameter
    parameters {
        string(name: 'TAG_TO_DEPLOY', defaultValue: 'latest', description: 'Image Version to Manually Deploy (e.g. "latest" or build number "45")')
    }

    environment {
        // --- CONFIGURATION ---
        SSH_CRED_ID      = "raspberry-pi-ssh"
        VAULT_CRED_ID    = "vault-prop-ferry-approle"
        REGISTRY_CRED_ID = "github-packages-pat"
        VAULT_ADDR       = 'http://vault:8200'
        
        DEPLOY_USER = "dietpi"
        DEPLOY_HOST = "10.100.10.5"
        DEPLOY_DIR  = "/opt/homelab-iac/services/apps/prop-ferry-website"

        // Image names for notifications
        IMAGE_BACKEND  = "rajivghandi767/prop-ferry-backend"
        IMAGE_FRONTEND = "rajivghandi767/prop-ferry-frontend"
        IMAGE_NGINX    = "rajivghandi767/prop-ferry-nginx"

        // --- NOTIFICATIONS ---
        JENKINS_DISCORD_WEBHOOK = credentials('jenkins-discord-webhook')
    }

    stages {
        // --- STAGE 1: CHECK VAULT STATUS ---
        stage('üîç Check Status') {
            steps {
                script {
                    echo "Checking Vault Seal Status..."
                    def statusJson = sh(script: "curl -s ${VAULT_ADDR}/v1/sys/seal-status || wget -qO- ${VAULT_ADDR}/v1/sys/seal-status", returnStdout: true).trim()
                    
                    if (statusJson.contains('"sealed":false')) {
                        echo "‚úÖ Vault is ALREADY UNSEALED. No action required."
                        env.VAULT_STATUS = "OPEN" 
                    } else {
                        echo "üîí Vault is SEALED. Initiating unseal sequence..."
                        env.VAULT_STATUS = "SEALED"
                    }
                }
            }
        }

        // --- STAGE 2: INJECT KEYS (ONLY IF SEALED) ---
        stage('üóùÔ∏è Inject Keys') {
            when {
                environment name: 'VAULT_STATUS', value: 'SEALED'
            }
            steps {
                withCredentials([
                    string(credentialsId: 'VAULT_UNSEAL_KEY_1', variable: 'KEY1'),
                    string(credentialsId: 'VAULT_UNSEAL_KEY_2', variable: 'KEY2'),
                    string(credentialsId: 'VAULT_UNSEAL_KEY_3', variable: 'KEY3')
                ]) {
                    script {
                        for (int i = 1; i <= 3; i++) {
                            echo "üöÄ Injecting Key #${i}..."
                            def currentKeyVar = "\$KEY${i}"
                            
                            def output = sh(script: """
                                if command -v curl >/dev/null 2>&1; then
                                    curl -s -X POST -H "Content-Type: application/json" -d "{\\"key\\": \\"${currentKeyVar}\\"}" ${VAULT_ADDR}/v1/sys/unseal
                                else
                                    wget -qO- --post-data "{\\"key\\": \\"${currentKeyVar}\\"}" --header="Content-Type: application/json" ${VAULT_ADDR}/v1/sys/unseal
                                fi
                            """, returnStdout: true).trim()
                            
                            if (output.contains('"sealed":false')) {
                                echo "üéâ SUCCESS: Vault has been UNSEALED!"
                                return
                            } else {
                                echo "‚ö†Ô∏è Key accepted. Still sealed. Waiting for next key..."
                            }
                        }
                        error("‚õî All keys used but Vault is still sealed.")
                    }
                }
            }
        }

        // --- DEPLOY STAGE ---
        stage('Deploy Configuration') {
            steps {
                checkout scm

                // A. Fetch App Secrets from Vault
                withVault(configuration: [vaultUrl: "${VAULT_ADDR}", vaultCredentialId: "${VAULT_CRED_ID}", engineVersion: 2], 
                vaultSecrets: [[path: 'secret/prop-ferry-prod', secretValues: [
                    [envVar: 'DJANGO_SECRET_KEY', vaultKey: 'DJANGO_SECRET_KEY'],
                    [envVar: 'ALLOWED_HOSTS', vaultKey: 'ALLOWED_HOSTS'],
                    [envVar: 'CSRF_TRUSTED_ORIGINS', vaultKey: 'CSRF_TRUSTED_ORIGINS'],
                    [envVar: 'POSTGRES_HOST', vaultKey: 'POSTGRES_HOST'],
                    [envVar: 'POSTGRES_PORT', vaultKey: 'POSTGRES_PORT'],
                    [envVar: 'POSTGRES_USER', vaultKey: 'POSTGRES_USER'],
                    [envVar: 'POSTGRES_PASSWORD', vaultKey: 'POSTGRES_PASSWORD'],
                    [envVar: 'POSTGRES_DB', vaultKey: 'POSTGRES_DB'],
                    [envVar: 'ADMIN_URL', vaultKey: 'ADMIN_URL'],
                    [envVar: 'DISCORD_WEBHOOK_URL', vaultKey: 'DISCORD_WEBHOOK_URL'],
                ]]]) {
                    
                    withCredentials([usernamePassword(credentialsId: REGISTRY_CRED_ID, usernameVariable: 'REGISTRY_USER', passwordVariable: 'REGISTRY_PASS')]) {
                        script {
                            // C. Generate .env file LOCALLY
                            def envContent = """
                                IMAGE_TAG='${params.TAG_TO_DEPLOY}'
                                DJANGO_SECRET_KEY='${DJANGO_SECRET_KEY}'
                                ALLOWED_HOSTS='${ALLOWED_HOSTS}'
                                CSRF_TRUSTED_ORIGINS='${CSRF_TRUSTED_ORIGINS}'
                                POSTGRES_HOST='${POSTGRES_HOST}'
                                POSTGRES_PORT='${POSTGRES_PORT}'
                                POSTGRES_USER='${POSTGRES_USER}'
                                POSTGRES_PASSWORD='${POSTGRES_PASSWORD}'
                                POSTGRES_DB='${POSTGRES_DB}'
                                ADMIN_URL='${ADMIN_URL}'
                                DISCORD_WEBHOOK_URL='${DISCORD_WEBHOOK_URL}'
                            """.stripIndent()
                            
                            writeFile file: '.env.prod', text: envContent

                            sshagent([SSH_CRED_ID]) {
                                // D. Pre-flight Security
                                sh """
                                    mkdir -p ~/.ssh
                                    ssh-keyscan -H ${DEPLOY_HOST} >> ~/.ssh/known_hosts || true
                                """

                                // E. Transfer files
                                sh """
                                    echo "üì¶ Syncing files to ${DEPLOY_HOST}..."
                                    scp docker-compose.yml ${DEPLOY_USER}@${DEPLOY_HOST}:${DEPLOY_DIR}/docker-compose.yml
                                    scp .env.prod ${DEPLOY_USER}@${DEPLOY_HOST}:${DEPLOY_DIR}/.env
                                """

                                // F. Remote Execution
                                
                                // STEP A: Secure Login
                                sh "echo \$REGISTRY_PASS | ssh ${DEPLOY_USER}@${DEPLOY_HOST} 'docker login ghcr.io -u ${REGISTRY_USER} --password-stdin'"

                                // STEP B: Check for Updates
                                def isManualDeploy = params.TAG_TO_DEPLOY != 'latest'
                                def localCommit = sh(returnStdout: true, script: 'git rev-parse --short HEAD').trim()
                                
                                // Get Remote Running Commit
                                def remoteCommit = sh(script: """
                                    ssh ${DEPLOY_USER}@${DEPLOY_HOST} "
                                        cd ${DEPLOY_DIR}
                                        CID=\\\$(docker compose ps -q prop-ferry-backend 2>/dev/null)
                                        if [ ! -z \\\"\\\$CID\\\" ]; then
                                            docker inspect --format '{{ index .Config.Labels \\"git-commit\\" }}' \\\$CID
                                        fi
                                    "
                                """, returnStdout: true).trim()

                                echo "üîé Version Check: Local [${localCommit}] vs Remote [${remoteCommit}]"
                                
                                def shouldDeploy = false
                                if (isManualDeploy) {
                                    echo "‚ö†Ô∏è Manual Deployment requested."
                                    shouldDeploy = true
                                } else if (localCommit == remoteCommit) {
                                    echo "‚úÖ Code hashes match. Skipping unnecessary pull/deploy."
                                    shouldDeploy = false
                                } else {
                                    echo "üöÄ Code Change detected. Pulling images..."
                                    
                                    def pullOutput = sh(script: """
                                        ssh ${DEPLOY_USER}@${DEPLOY_HOST} "
                                            cd ${DEPLOY_DIR}
                                            IMAGE_TAG=${params.TAG_TO_DEPLOY} docker compose pull 2>&1
                                        "
                                    """, returnStdout: true).trim()
                                    echo "üîç Pull Status: \n${pullOutput}"
                                    shouldDeploy = true
                                }

                                // STEP C: Conditional Deploy
                                if (shouldDeploy) {
                                    echo "üöÄ Deploying..."
                                    sh """
                                        ssh ${DEPLOY_USER}@${DEPLOY_HOST} "
                                            cd ${DEPLOY_DIR}
                                            chmod 600 .env
                                            IMAGE_TAG=${params.TAG_TO_DEPLOY} docker compose up -d --remove-orphans
                                            docker image prune -f
                                        "
                                    """
                                    currentBuild.result = 'SUCCESS'
                                    env.DEPLOY_STATUS = "UPDATED"
                                } else {
                                    echo "üí§ No changes found. Skipping deploy."
                                    currentBuild.result = 'SUCCESS'
                                    env.DEPLOY_STATUS = "SKIPPED"
                                }
                                
                                // STEP D: Always Logout
                                sh "ssh ${DEPLOY_USER}@${DEPLOY_HOST} 'docker logout ghcr.io'"

                                // G. Cleanup Local Secrets
                                sh "rm .env.prod"
                            }
                        }
                    }
                }
            }
        }
    }

    // 3. Discord Notifications
    post {
        success {
            script {
                def timestamp = sh(returnStdout: true, script: "TZ='America/New_York' date +'%a, %d %b %Y at %H:%M %Z'").trim()

                if (env.DEPLOY_STATUS == "UPDATED") {
                    def deployMessage = """
:unicorn: **Prop & Ferry Web App Update Deployed**
**:new: New Version Live:**
‚Ä¢ **Tag:** ${params.TAG_TO_DEPLOY}
‚Ä¢ **Backend:** ${IMAGE_BACKEND}
‚Ä¢ **Frontend:** ${IMAGE_FRONTEND}
‚Ä¢ **Nginx:** ${IMAGE_NGINX}

:bar_chart: **Status:** Healthy
:clock4: **Time:** ${timestamp}
"""
                    discordSend description: deployMessage, result: 'SUCCESS', title: "üöÄ Deployment Successful", webhookURL: env.JENKINS_DISCORD_WEBHOOK
                } 
                else if (env.DEPLOY_STATUS == "SKIPPED") {
                    def skipMessage = """
:shield: **Prop & Ferry Web App Up to Date**
No new code changes found for tag: **${params.TAG_TO_DEPLOY}**.
Running services remain unchanged.

:clock4: **Time:** ${timestamp}
"""
                    discordSend description: skipMessage, result: 'SUCCESS', title: "‚úÖ Check Complete: No Changes", webhookURL: env.JENKINS_DISCORD_WEBHOOK
                }
            }
        }
        failure {
            script {
                def failTime = sh(returnStdout: true, script: "TZ='America/New_York' date +'%a, %d %b %Y at %H:%M %Z'").trim()
                def failMessage = """
:x: **Prop & Ferry Web App Deployment Failed**
**:warning: Error Details:**
Check Jenkins logs for build #${BUILD_NUMBER}.
:wrench: **Action Required:** Manual intervention needed.

:clock4: **Time:** ${failTime}
"""
                discordSend description: failMessage, result: 'FAILURE', title: "üö® Deployment Alert", webhookURL: env.JENKINS_DISCORD_WEBHOOK
            }
        }
    }
}